/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rivermonitoringservice.mqtt;

import java.nio.charset.StandardCharsets;
import java.util.UUID;
import com.hivemq.client.mqtt.MqttGlobalPublishFilter;
import com.hivemq.client.mqtt.datatypes.MqttQos;
import com.hivemq.client.mqtt.mqtt5.Mqtt5AsyncClient;
import com.hivemq.client.mqtt.mqtt5.Mqtt5Client;
import com.hivemq.client.mqtt.mqtt5.message.publish.Mqtt5Publish;
import com.hivemq.embedded.EmbeddedHiveMQ;
import com.hivemq.embedded.EmbeddedHiveMQBuilder;

import rivermonitoringservice.Constants;

public class MqttManager {

    private static final String WATER_LEVEL_TOPIC_NAME = "esiot-2024/group-4/water-level";
    private static final String MEASUREMENT_FREQUENCY_TOPIC_NAME = "esiot-2024/group-4/measurement-frequency";
    private double waterLevel = Constants.waterLevel1; // initialising to safe water level value
    private Mqtt5AsyncClient client;

    public String getGreeting() {
        return "Hello World!";
    }

    public void startMqttServer() {
        /* Creation of the broker */
        final EmbeddedHiveMQBuilder embeddedHiveMQBuilder = EmbeddedHiveMQBuilder.builder();
        final EmbeddedHiveMQ hiveMQ = embeddedHiveMQBuilder.build();
        try {
            hiveMQ.start().join();
            System.out.println("MQTT broker launched correctly.");
        } catch (final Exception ex) {
            System.out.println("Error while launching or stopping MQTT broker...");
            ex.printStackTrace();
        }

        /* Creation of the subscriber. Differently from the test version in the WaterLevelMonitoring folder,
         * this client was built in an asynchronous way. If I understood correctly, the callback function provided
         * as a Consumer<Mqtt5Publish> is automatically called each time an asynchronous communication event
         * occurs, so there's no need for infinite loops.
         * 
         * I used the following guide to implement this code:
         * https://www.hivemq.com/blog/mqtt-client-api/the-hivemq-mqtt-client-library-for-java-and-its-async-api-flavor/
         * 
         * For comparison, it might be useful to check the blocking alternative:
         * https://www.hivemq.com/blog/mqtt-client-api/the-hivemq-mqtt-client-library-for-java-and-its-blocking-api-flavor/
         * 
         * Important note: it is good practice to add the callback function before connecting to the server, so
         * as not to lose information during the connection process.
         */
        this.client = Mqtt5Client.builder()
                .identifier(UUID.randomUUID().toString())
                .serverHost("broker.hivemq.com")
                .buildAsync(); // the asynchronous version of the client
        
        /*
         * The Mqtt5AsyncClient.publishes() method takes 2 parameters:
         * 1) the topic filter, allowing the system to discard irrelevant MQTT packets;
         * 2) the callback function to process the received information with; it's a Consumer<Mqtt5Publish>.
         * 
         * The only relevant thing this callback does is set the water level to the read value.
         */
        this.client.publishes(MqttGlobalPublishFilter.ALL, publishedData -> {
            final String receivedMessage = new String(publishedData.getPayloadAsBytes(), StandardCharsets.UTF_8);
            System.out.println("\nReceived message: " + receivedMessage);
            this.waterLevel = Double.parseDouble(receivedMessage.replaceAll("(\\r|\\n)", ""));
            System.out.println("Successfully parsed the following double: " + this.waterLevel);
            System.out.println("\n\nReceiving messages...");
        });
        
        client.connect();

        /* Subscription of the client that runs on the backend. */
        client.subscribeWith().topicFilter(MqttManager.WATER_LEVEL_TOPIC_NAME).qos(MqttQos.AT_LEAST_ONCE).send();
        System.out.println("Subscription occurred");

        /* UNREACHABLE CODE; ideally, the server should always be up. */
        /* client.disconnect();
        hiveMQ.stop();
        try {
            // I must remember to call close, otherwise the program never ends.
            hiveMQ.close();
        } catch (ExecutionException | InterruptedException e) {
            System.out.println("Error while trying to close broker");
            e.printStackTrace();
        }
        System.out.println("MQTT broker stopped correctly."); */
    }

    public void communicateNewMeasurementFrequency(final int mFrequency) {
        final Mqtt5Publish publish = Mqtt5Publish.builder()
                .topic(MqttManager.MEASUREMENT_FREQUENCY_TOPIC_NAME)
                .payload(String.valueOf(mFrequency).getBytes())
                .qos(MqttQos.AT_LEAST_ONCE)
                .build();
        this.client.publish(publish);
        System.out.println("Successfully published measurement frequency: "
                            + mFrequency
                            + " to ESP (Water Monitoring System).");
    }

    public double getWaterLevel() {
        return this.waterLevel;
    }
}
