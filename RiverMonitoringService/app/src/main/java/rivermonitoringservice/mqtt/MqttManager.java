/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rivermonitoringservice.mqtt;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

import com.hivemq.client.mqtt.MqttGlobalPublishFilter;
import com.hivemq.client.mqtt.datatypes.MqttQos;
import com.hivemq.client.mqtt.mqtt5.Mqtt5BlockingClient;
import com.hivemq.client.mqtt.mqtt5.Mqtt5Client;
import com.hivemq.client.mqtt.mqtt5.Mqtt5BlockingClient.Mqtt5Publishes;
import com.hivemq.embedded.EmbeddedHiveMQ;
import com.hivemq.embedded.EmbeddedHiveMQBuilder;

import rivermonitoringservice.Constants;

public class MqttManager {

    private static final String TOPIC_NAME = "esiot-2024/group-4/water-level";
    private double waterLevel = Constants.waterLevel1; // initialising to safe water level value

    public String getGreeting() {
        return "Hello World!";
    }

    public void startMqttServer() {
        /* Creation of the broker */
        final EmbeddedHiveMQBuilder embeddedHiveMQBuilder = EmbeddedHiveMQBuilder.builder();
        final EmbeddedHiveMQ hiveMQ = embeddedHiveMQBuilder.build();
        try {
            hiveMQ.start().join();
            System.out.println("MQTT broker launched correctly.");
        } catch (final Exception ex) {
            System.out.println("Error while launching or stopping MQTT broker...");
            ex.printStackTrace();
        }

        /* Creation of the subscriber */
        Mqtt5BlockingClient client = Mqtt5Client.builder()
                .identifier(UUID.randomUUID().toString())
                .serverHost("broker.hivemq.com")
                .buildBlocking();
        client.connect();

        /* Subscription of the client that runs on the backend. */
        client.subscribeWith().topicFilter(MqttManager.TOPIC_NAME).qos(MqttQos.AT_LEAST_ONCE).send();
        System.out.println("Subscription occurred");

        while (true) {
            try (final Mqtt5Publishes publishes = client.publishes(MqttGlobalPublishFilter.ALL)) {
                /* There are two versions of publishes.receive(), the one that takes no arguments
                 * is blocking.
                 */
                String messageString = new String(publishes.receive().getPayloadAsBytes(), StandardCharsets.US_ASCII);
                System.out.println("\nReceived message: " + messageString);
                this.waterLevel = Double.parseDouble(messageString.replaceAll("(\\r|\\n)", ""));
                System.out.println("Successfully parsed the following double: " + this.waterLevel);
                System.out.println("\n\n Receiving messages...");
                /* publishes.receive(1, TimeUnit.SECONDS).ifPresent(System.out::println);
                publishes.receive(100, TimeUnit.MILLISECONDS).ifPresent(System.out::println);
                System.out.println("\n\nSubscription and reception occurred\n\n"); */
            } catch (Exception e) {
                System.out.println("\n\nException occurred while subscribing!\n\n");
                e.printStackTrace();
            }
        }
        /* UNREACHABLE CODE; ideally, the server should always be up. */
        /* client.disconnect();
        hiveMQ.stop();
        try {
            // I must remember to call close, otherwise the program never ends.
            hiveMQ.close();
        } catch (ExecutionException | InterruptedException e) {
            System.out.println("Error while trying to close broker");
            e.printStackTrace();
        }
        System.out.println("MQTT broker stopped correctly."); */
    }

    public double getWaterLevel() {
        return this.waterLevel;
    }
}
